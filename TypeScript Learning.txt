
2020.10.26  1.37 am
1. extension of TypeScript document is .ts

2. install TypeScript: npm install -g typescript

    version：  tsc -v

3. tsc test.ts   ---> generate test.js

4. tsc -init ---->generate tsconfig,json

5. Modify "outDir": "./js"   in VSCode, Terminal  -->Run Task--->TypeScript-->tsc:watch-tsconfig.json 
    As long as .ts is modified, .js document in js fold could be modified and compiled to .js document. 

or   tsc test --watch  , generate a .js doc in the same folder.
----------------------------------------------------------------------------------------------------------
2020.10.27 1.57am

1. variable declaration
let a;
a=10;
a=true;      //ok

let b=20;
b= true     //wrong, true cannot be assigned to b

let multipleType: number | boolean;
multipleType=20;
multipleType=true;      //ok

let anyType:any;
anyType=20;
anyType=true;  //ok

2. function

function add(num1:number,num2:number):number{
    return num1+num2;
}
console.log(add(23,5))

function add(num1:number,num2?:number):number{     // ? means optional parameter
    if(num2)   //if mnum2 is not null, is a number
        return num1+num2;
    else
        return num1
}
console.log(add(3))


function FullName(person:{firstName:string, lastName:string}){
    console.log(person.firstName,person.lastName);
}

let p = {
    firstName: 'Felix',
    lastName: 'Wang'
};
FullName(p)

3. Interface
interface Person{
    firstName:string;
    lastName:string;
}

function FullName(person:Person){
    console.log(person.firstName,person.lastName);
}

let p = {
    firstName: 'Felix',
    lastName: 'Wang'
};
FullName(p)


4. Class

class Employee {
    employeeName:string;
    constructor(name:string){
        this.employeeName=name;
    }
    greet(){
        console.log('Good morning,',this.employeeName)
    }
}

let emp1=new Employee("Sherry");
console.log(emp1.employeeName);
emp1.greet();

class Manager extends Employee{
    constructor(managerName:string){
        super(managerName);
    }
    delegateWork(){
        console.log('Manager delegate tasks');
    }
}
let mag1=new Manager("Felix");
mag1.delegateWork();
mag1.greet();
console.log(mag1.employeeName);

5.array

// foreach the array
let colors: string[]=["red","white","green"];
for(let i of colors){
console.log(i);
}
-------------------------------------------------
2020 10.28

class can include the static properties and static functions.

static functions can only use the static properties.

//class and inherit
class Person {
    public name:string;
    static age:number;   //static property
    constructor(name:string){
        this.name=name;
    }
    run1():string{
        return this.name+' is running';
    }
    static run2():number{
        return this.age;
    }

}


polymorphic 多态

abstract class and abstract method
abstract class cannot be instanced.
abstract method is only in abstract class.
abstract method does not include detailed implementation.
The child class must implement the abstract method in abstract class.

abstract class Animal{
    abstract eat():any;
}
//var v=new Animal();   //error, cannot create an instance of an abstract class


interface

interface FullName{
    firstName:string;
    lastName:String
}

function printName(name:FullName):void{
    console.log(name.firstName+' and '+name.lastName);
}

printName({firstName:'Felix', lastName:'wang'});
--------------------------------------------------------
2020 10.28 2.30 pm

Generics
solve the reusability of class, function, interface etc.
Generics can support unspecific data type, but the return parameters should be consistant with input parameters
//T stands for Generics

//Generics class      add <T> behind the class name 

class MinClass<T>{
    public list:T[]=[];
    add(value:T):void{
        this.list.push(value);
    }

    Min():T{
        var min=this.list[0];
        for(var i=0;i<this.list.length;i++){
            if(min>this.list[i]){
                min=this.list[i];
            }
        }
        return min;
    }
}
 var m1=new MinClass<Number>();
 m1.add(4);
 m1.add(7);
 m1.add(3);
 console.log(m1.Min());

 var m2=new MinClass<string>();
 m2.add('b');
 m2.add('g');
 m2.add('r');
 console.log(m2.Min());

 //interface Generics
interface ConfigFn<T>{
    (value:T):T;
    
}

function getData2<T>(value:T):T{
    return value;
}
var myGetData:ConfigFn<string>=getData2;

myGetData('ser');
console.log(myGetData('ser'));
--------------------------------------
module

use export, if some files import it, the methods can be used


export var dbUrl='xxxx'    //export the variable
export function getDbData():any[]{
    console.log('get data from DB');
    return[
        {title:'123'},
        {type:'345'}
    ]
}
export function save(){
    console.log('save successfully');
}


use import 
import { getDbData, save } from './modules/db'
import { getDbData as getD, save } from './modules/db'   // use as to short the name
getDbData();
save();

export {dbUrl,getDbData,save}    //  another way to export

export default getDbData  // only one export default
import getDbData from './modules/db'
-----------------------------

namespace

one module can include many namespaces.

//decorator   can extend the methods and properties of the class
function decoratorName(params:any){
    console.log(params);
    params.prototype.apiUrl='xxxx';
}

@decoratorName
class HttpClient2{
    constructor(){}
    getData2(){};
}

var http:any=new HttpClient2();
console.log(http.apiUrl);